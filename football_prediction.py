# -*- coding: utf-8 -*-
"""football_prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qcyfAhRMO4XdM0gRqYWB-V2_AYSW58mt
"""

from google.colab import drive
!mkdir drive
drive.mount('/content/drive/')

import torch
import torch.nn as nn
from torch import optim
import torch.nn.functional as F
import random
import numpy as np
import pandas as pd
import glob
from copy import deepcopy
from torch.utils.data import Dataset,DataLoader

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
device

dir = "/content/drive/My Drive/ML/football/"
filelist = glob.glob(dir+'*.csv')
liss = []
rejectedfiles = []
colnames = ['AC',
 'AF',
 'AR',
 'AS',
 'AST',
 'AY',
 'AwayTeam',
 'Date',
 'Div',
 'FTAG',
 'FTHG',
 'FTR',
 'HC',
 'HF',
 'HR',
 'HS',
 'HST',
 'HTAG',
 'HTHG',
 'HTR',
 'HY',
 'HomeTeam',
 'IWA',
 'IWD',
 'IWH',
 'Referee',
 'WHA',
 'WHD',
 'WHH']
for f in filelist:
  try:
    df = pd.read_csv(f,index_col=None, header=0,usecols = colnames)
    df["Season"] = f[-8:-4]
    liss.append(df)
  except ValueError:
    rejectedfiles.append(f)
  dataset = pd.concat(liss,axis=0,ignore_index=True)

f = '/content/drive/My Drive/ML/football/1516.csv'
temp = pd.read_csv(f,header=0)
x = set(temp.columns)
for f in filelist:
  if f not in rejectedfiles:
    try:
      temp = pd.read_csv(f,header=0)
      x = x.intersection(set(temp.columns))
    except:
      continue

teams = deepcopy(list(set(dataset["HomeTeam"])))
seasons = deepcopy(list(set(dataset["Season"])))
teams_dict = {}
seasons_dict = {}
teams_dict = {teams[i] : i for i in range(len(teams))}
seasons_dict = {seasons[i] : i for i in range(len(seasons))}
dataset["HomeTeam"] = dataset["HomeTeam"].map(teams_dict).astype(int)
dataset["AwayTeam"] = dataset["AwayTeam"].map(teams_dict).astype(int)
dataset["Season"] = dataset["Season"].map(seasons_dict).astype(int)
dataset["HomePoints"] = dataset["FTR"].map({'H':3,'D':1,"A":0})
dataset["AwayPoints"] = dataset["FTR"].map({'H':0,'D':1,"A":3})
dataset["Result"] = dataset["FTR"].map({'H':0,'D':1,"A":2})

home_data_mean = dataset.groupby(['HomeTeam','Season']).mean()
away_data_mean = dataset.groupby(['AwayTeam','Season']).mean()
home_data_sum = dataset.groupby(['HomeTeam','Season']).sum()
away_data_sum = dataset.groupby(['AwayTeam','Season']).sum()
home_data_sum = dataset["FTHG","HC","HF","HR","HS","HST","HY","HTHG","IWH","IWH"

outputvec = np.asarray(dataset["Result"])
inputvec = np.asarray(dataset[["HomeTeam","AwayTeam"]])

class Football(Dataset):
  def __init__(self,x,y):
    super(Dataset,self).__init__()
    self.len = len(x)
    self.x = torch.as_tensor(x, device=device, dtype=torch.long)
    self.y = torch.as_tensor(y, device=device, dtype=torch.long)
  def __len__(self):
    return self.len
  def __getitem__(self,index):
    return self.x[index],self.y[index]

data = Football(inputvec,outputvec)

train_loader = DataLoader(dataset = data, batch_size = 5, shuffle = False)
train_loader

class WinLossClassifier(nn.Module):
  def __init__(self,inputsize, hidden):
    super(WinLossClassifier, self).__init__()
    self.embedding = nn.Embedding(inputsize,hidden)
    self.lc1 = nn.Linear(hidden*2,hidden)
    self.lc2 = nn.Linear(hidden,3)
    self.softmax = nn.LogSoftmax()
  def forward(self, home, away):
    home = self.embedding(home)
    away = self.embedding(away)
    output = torch.cat((home,away),dim=1)
    output = self.lc1(output)
    output = self.lc2(output)
    return self.softmax(output)

model = WinLossClassifier(len(teams_dict),10)
criterion = nn.NLLLoss()
optimizer = optim.Adam(model.parameters(),lr=0.001)
epochs = 100
for i in range(epochs):
  for idx, (inputvec,labels) in enumerate(train_loader):
    optimizer.zero_grad()
    home = inputvec[:,0]
    away = inputvec[:,1]
    output = model(home,away)
    loss = criterion(output,labels)
    print(loss.item())
    loss.backward()

m = nn.LogSoftmax()
loss = nn.NLLLoss()
input = torch.randn(3, 5, requires_grad=True)
target = torch.tensor([1, 0, 4])
output = loss(m(input), target)
target = torch.empty(3, dtype=torch.long).random_(5)
target